# Inference Service (Порт: 8003)

## Обзор

**Inference Service** — сервис детекции объектов с использованием YOLO модели. Сервис обрабатывает отдельные кадры видео, выполняет детекцию объектов и возвращает результаты в формате JSON.

## Архитектура обработки

1. **Читает задачи** из Kafka темы `inference_tasks` (с путями к кадрам в S3)
2. **Скачивает кадр** из S3 бакета "frames" по пути из сообщения
3. **Запускает YOLO детекцию** на скачанном кадре
4. **Отправляет JSON результат** для кадра в Kafka тему `inference_results`

## Внутренние компоненты

### Kafka Consumer/Producer

#### Consumer для задач инференса
- **Тема**: `inference_tasks`
- **Группа**: `inference-group`
- **Функция**: Получение кадров для детекции

#### Producer для результатов
- **Тема**: `inference_results`
- **Функция**: Отправка результатов детекции

### YOLO Модель

#### Конфигурация модели
- **Файл модели**: `best.pt` (веса YOLO, используется модель YOLOv8)
- **Порог уверенности**: `conf=0.25` (снижен для лучшего распознавания животных)
- **Порог IoU**: `iou=0.45` (более строгий для фильтрации дубликатов)

### Борьба с GIL (Global Interpreter Lock)

**GIL (Global Interpreter Lock)** — это механизм в CPython, который предотвращает одновременное выполнение байт-кода несколькими потоками в одном процессе.

**Проблема в Inference Service**:
- YOLO детекция — CPU-интенсивная операция
- Если выполнять YOLO обработку в основном потоке, GIL блокирует выполнение других задач
- `ThreadPoolExecutor` не обеспечивает истинного параллелизма из-за GIL

**Решение**:
1. **ProcessPoolExecutor** (через `run_in_executor(executor, ...)`) для YOLO обработки:
   - Каждый процесс имеет свой GIL, что обеспечивает истинный параллелизм
   - Можно обрабатывать несколько кадров одновременно на разных ядрах CPU
   - Event loop не блокируется
   - Модель YOLO загружается в каждом процессе отдельно (кэшируется внутри процесса)

**Преимущества ProcessPoolExecutor**:
- **Истинный параллелизм**: Несколько кадров обрабатываются одновременно на разных ядрах CPU
- **Обход GIL**: Каждый процесс имеет свой GIL
- **Высокая производительность**: Значительное ускорение на многоядерных системах (200-300% улучшение)
- **Масштабируемость**: Автоматическое использование всех доступных ядер CPU

## Процесс обработки кадра

### 1. Получение задачи
### 2. Скачивание фрейма
### 3. Детекция объекта
### 4. Форматирование результата
### 5. Отправка результата

## Очерёдность кадров

Очерёдность обеспечивается через:
- **Kafka Consumer Groups**: Все кадры одного видео обрабатываются последовательно
- **frame_id**: Уникальный номер кадра для правильной сборки JSON
- **Сохранение frame_id**: Включается в результат для сборки в runner

## Настройка модели

### Смена модели
Чтобы сменить модель, обновите путь в двух местах:
1. `yolo_detect_frame.py`: `yolo_path='best.pt'`
2. `kafka_consumer.py`: `yolo_path='best.pt'`

### Параметры детекции
- `conf=0.25` — порог уверенности (снижен для животных)
- `iou=0.45` — порог IoU для NMS

## Отказоустойчивость и проверка доступности сервисов

### Проверка доступности Kafka

## Идемпотентность

**Идемпотентные операции**:
- **Детекция кадров**: Каждый кадр обрабатывается независимо
- **Отправка результатов**: Результаты содержат frame_id для сборки
- **Kafka сообщения**: Используются message keys для порядка обработки

**Реализация идемпотентности**:
- **Frame ID**: Каждый результат содержит уникальный номер кадра
- **Независимая обработка**: Кадры обрабатываются независимо друг от друга
- **Порядок сборки**: Runner сервис сортирует результаты по frame_id